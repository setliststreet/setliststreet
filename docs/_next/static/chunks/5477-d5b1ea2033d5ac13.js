"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[5477],{1511:(e,t,r)=>{r.d(t,{b:()=>n});function n(e,t,r,n){let i=r?r.call(n,e,t):void 0;if(void 0!==i)return!!i;if(e===t)return!0;if("object"!=typeof e||!e||"object"!=typeof t||!t)return!1;let o=Object.keys(e),s=Object.keys(t);if(o.length!==s.length)return!1;let a=Object.prototype.hasOwnProperty.bind(t);for(let s=0;s<o.length;s++){let c=o[s];if(!a(c))return!1;let d=e[c],l=t[c];if(!1===(i=r?r.call(n,d,l,c):void 0)||void 0===i&&d!==l)return!1}return!0}},1649:(e,t,r)=>{r.d(t,{I:()=>i});var n=r(4232);function i(e,t){let r=[...t||[]];return null==t&&"function"!=typeof e&&r.push(e),(0,n.useMemo)(()=>"function"==typeof e?e():e,r)}},3845:(e,t,r)=>{r.d(t,{H:()=>v});var n=r(8333),i=r(1649),o=r(4232),s=r(1511),a=r(7172),c=r(9006);class d{get connectTarget(){return this.dropTarget}reconnect(){let e=this.didHandlerIdChange()||this.didDropTargetChange()||this.didOptionsChange();e&&this.disconnectDropTarget();let t=this.dropTarget;if(this.handlerId){if(!t){this.lastConnectedDropTarget=t;return}e&&(this.lastConnectedHandlerId=this.handlerId,this.lastConnectedDropTarget=t,this.lastConnectedDropTargetOptions=this.dropTargetOptions,this.unsubscribeDropTarget=this.backend.connectDropTarget(this.handlerId,t,this.dropTargetOptions))}}receiveHandlerId(e){e!==this.handlerId&&(this.handlerId=e,this.reconnect())}get dropTargetOptions(){return this.dropTargetOptionsInternal}set dropTargetOptions(e){this.dropTargetOptionsInternal=e}didHandlerIdChange(){return this.lastConnectedHandlerId!==this.handlerId}didDropTargetChange(){return this.lastConnectedDropTarget!==this.dropTarget}didOptionsChange(){return!(0,s.b)(this.lastConnectedDropTargetOptions,this.dropTargetOptions)}disconnectDropTarget(){this.unsubscribeDropTarget&&(this.unsubscribeDropTarget(),this.unsubscribeDropTarget=void 0)}get dropTarget(){return this.dropTargetNode||this.dropTargetRef&&this.dropTargetRef.current}clearDropTarget(){this.dropTargetRef=null,this.dropTargetNode=null}constructor(e){this.hooks=(0,c.i)({dropTarget:(e,t)=>{this.clearDropTarget(),this.dropTargetOptions=t,(0,a.i)(e)?this.dropTargetRef=e:this.dropTargetNode=e,this.reconnect()}}),this.handlerId=null,this.dropTargetRef=null,this.dropTargetOptionsInternal=null,this.lastConnectedHandlerId=null,this.lastConnectedDropTarget=null,this.lastConnectedDropTargetOptions=null,this.backend=e}}var l=r(4138),u=r(8026),g=r(8121);let h=!1;class p{receiveHandlerId(e){this.targetId=e}getHandlerId(){return this.targetId}subscribeToStateChange(e,t){return this.internalMonitor.subscribeToStateChange(e,t)}canDrop(){if(!this.targetId)return!1;(0,g.V)(!h,"You may not call monitor.canDrop() inside your canDrop() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor");try{return h=!0,this.internalMonitor.canDropOnTarget(this.targetId)}finally{h=!1}}isOver(e){return!!this.targetId&&this.internalMonitor.isOverTarget(this.targetId,e)}getItemType(){return this.internalMonitor.getItemType()}getItem(){return this.internalMonitor.getItem()}getDropResult(){return this.internalMonitor.getDropResult()}didDrop(){return this.internalMonitor.didDrop()}getInitialClientOffset(){return this.internalMonitor.getInitialClientOffset()}getInitialSourceClientOffset(){return this.internalMonitor.getInitialSourceClientOffset()}getSourceClientOffset(){return this.internalMonitor.getSourceClientOffset()}getClientOffset(){return this.internalMonitor.getClientOffset()}getDifferenceFromInitialOffset(){return this.internalMonitor.getDifferenceFromInitialOffset()}constructor(e){this.targetId=null,this.internalMonitor=e.getMonitor()}}var f=r(4410);class D{canDrop(){let e=this.spec,t=this.monitor;return!e.canDrop||e.canDrop(t.getItem(),t)}hover(){let e=this.spec,t=this.monitor;e.hover&&e.hover(t.getItem(),t)}drop(){let e=this.spec,t=this.monitor;if(e.drop)return e.drop(t.getItem(),t)}constructor(e,t){this.spec=e,this.monitor=t}}function v(e,t){let r=(0,i.I)(e,t),s=function(){let e=(0,l.u)();return(0,o.useMemo)(()=>new p(e),[e])}(),a=function(e){let t=(0,l.u)(),r=(0,o.useMemo)(()=>new d(t.getBackend()),[t]);return(0,u.E)(()=>(r.dropTargetOptions=e||null,r.reconnect(),()=>r.disconnectDropTarget()),[e]),r}(r.options),c=(0,l.u)(),h=function(e,t){let r=(0,o.useMemo)(()=>new D(e,t),[t]);return(0,o.useEffect)(()=>{r.spec=e},[e]),r}(r,s),v=function(e){let{accept:t}=e;return(0,o.useMemo)(()=>((0,g.V)(null!=e.accept,"accept must be defined"),Array.isArray(t)?t:[t]),[t])}(r);return(0,u.E)(function(){let[e,t]=(0,f.l)(v,h,c);return s.receiveHandlerId(e),a.receiveHandlerId(e),t},[c,s,h,a,v.map(e=>e.toString()).join("|")]),[(0,n.j)(r.collect,s,a),(0,o.useMemo)(()=>a.hooks.dropTarget(),[a])]}},4138:(e,t,r)=>{r.d(t,{u:()=>s});var n=r(8121),i=r(4232),o=r(9325);function s(){let{dragDropManager:e}=(0,i.useContext)(o.M);return(0,n.V)(null!=e,"Expected drag drop context"),e}},4349:e=>{e.exports=function e(t,r){if(t===r)return!0;if(t&&r&&"object"==typeof t&&"object"==typeof r){if(t.constructor!==r.constructor)return!1;if(Array.isArray(t)){if((n=t.length)!=r.length)return!1;for(i=n;0!=i--;)if(!e(t[i],r[i]))return!1;return!0}if(t.constructor===RegExp)return t.source===r.source&&t.flags===r.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===r.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===r.toString();if((n=(o=Object.keys(t)).length)!==Object.keys(r).length)return!1;for(i=n;0!=i--;)if(!Object.prototype.hasOwnProperty.call(r,o[i]))return!1;for(i=n;0!=i--;){var n,i,o,s=o[i];if(!e(t[s],r[s]))return!1}return!0}return t!=t&&r!=r}},4410:(e,t,r)=>{function n(e,t,r){let n=r.getRegistry(),i=n.addTarget(e,t);return[i,()=>n.removeTarget(i)]}function i(e,t,r){let n=r.getRegistry(),i=n.addSource(e,t);return[i,()=>n.removeSource(i)]}r.d(t,{V:()=>i,l:()=>n})},5185:(e,t,r)=>{r.d(t,{i:()=>I});var n=r(8121),i=r(8333),o=r(1649),s=r(4232),a=r(1511),c=r(7172),d=r(9006);class l{receiveHandlerId(e){this.handlerId!==e&&(this.handlerId=e,this.reconnect())}get connectTarget(){return this.dragSource}get dragSourceOptions(){return this.dragSourceOptionsInternal}set dragSourceOptions(e){this.dragSourceOptionsInternal=e}get dragPreviewOptions(){return this.dragPreviewOptionsInternal}set dragPreviewOptions(e){this.dragPreviewOptionsInternal=e}reconnect(){let e=this.reconnectDragSource();this.reconnectDragPreview(e)}reconnectDragSource(){let e=this.dragSource,t=this.didHandlerIdChange()||this.didConnectedDragSourceChange()||this.didDragSourceOptionsChange();return t&&this.disconnectDragSource(),this.handlerId&&(e?t&&(this.lastConnectedHandlerId=this.handlerId,this.lastConnectedDragSource=e,this.lastConnectedDragSourceOptions=this.dragSourceOptions,this.dragSourceUnsubscribe=this.backend.connectDragSource(this.handlerId,e,this.dragSourceOptions)):this.lastConnectedDragSource=e),t}reconnectDragPreview(e=!1){let t=this.dragPreview,r=e||this.didHandlerIdChange()||this.didConnectedDragPreviewChange()||this.didDragPreviewOptionsChange();if(r&&this.disconnectDragPreview(),this.handlerId){if(!t){this.lastConnectedDragPreview=t;return}r&&(this.lastConnectedHandlerId=this.handlerId,this.lastConnectedDragPreview=t,this.lastConnectedDragPreviewOptions=this.dragPreviewOptions,this.dragPreviewUnsubscribe=this.backend.connectDragPreview(this.handlerId,t,this.dragPreviewOptions))}}didHandlerIdChange(){return this.lastConnectedHandlerId!==this.handlerId}didConnectedDragSourceChange(){return this.lastConnectedDragSource!==this.dragSource}didConnectedDragPreviewChange(){return this.lastConnectedDragPreview!==this.dragPreview}didDragSourceOptionsChange(){return!(0,a.b)(this.lastConnectedDragSourceOptions,this.dragSourceOptions)}didDragPreviewOptionsChange(){return!(0,a.b)(this.lastConnectedDragPreviewOptions,this.dragPreviewOptions)}disconnectDragSource(){this.dragSourceUnsubscribe&&(this.dragSourceUnsubscribe(),this.dragSourceUnsubscribe=void 0)}disconnectDragPreview(){this.dragPreviewUnsubscribe&&(this.dragPreviewUnsubscribe(),this.dragPreviewUnsubscribe=void 0,this.dragPreviewNode=null,this.dragPreviewRef=null)}get dragSource(){return this.dragSourceNode||this.dragSourceRef&&this.dragSourceRef.current}get dragPreview(){return this.dragPreviewNode||this.dragPreviewRef&&this.dragPreviewRef.current}clearDragSource(){this.dragSourceNode=null,this.dragSourceRef=null}clearDragPreview(){this.dragPreviewNode=null,this.dragPreviewRef=null}constructor(e){this.hooks=(0,d.i)({dragSource:(e,t)=>{this.clearDragSource(),this.dragSourceOptions=t||null,(0,c.i)(e)?this.dragSourceRef=e:this.dragSourceNode=e,this.reconnectDragSource()},dragPreview:(e,t)=>{this.clearDragPreview(),this.dragPreviewOptions=t||null,(0,c.i)(e)?this.dragPreviewRef=e:this.dragPreviewNode=e,this.reconnectDragPreview()}}),this.handlerId=null,this.dragSourceRef=null,this.dragSourceOptionsInternal=null,this.dragPreviewRef=null,this.dragPreviewOptionsInternal=null,this.lastConnectedHandlerId=null,this.lastConnectedDragSource=null,this.lastConnectedDragSourceOptions=null,this.lastConnectedDragPreview=null,this.lastConnectedDragPreviewOptions=null,this.backend=e}}var u=r(4138),g=r(8026);let h=!1,p=!1;class f{receiveHandlerId(e){this.sourceId=e}getHandlerId(){return this.sourceId}canDrag(){(0,n.V)(!h,"You may not call monitor.canDrag() inside your canDrag() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");try{return h=!0,this.internalMonitor.canDragSource(this.sourceId)}finally{h=!1}}isDragging(){if(!this.sourceId)return!1;(0,n.V)(!p,"You may not call monitor.isDragging() inside your isDragging() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");try{return p=!0,this.internalMonitor.isDraggingSource(this.sourceId)}finally{p=!1}}subscribeToStateChange(e,t){return this.internalMonitor.subscribeToStateChange(e,t)}isDraggingSource(e){return this.internalMonitor.isDraggingSource(e)}isOverTarget(e,t){return this.internalMonitor.isOverTarget(e,t)}getTargetIds(){return this.internalMonitor.getTargetIds()}isSourcePublic(){return this.internalMonitor.isSourcePublic()}getSourceId(){return this.internalMonitor.getSourceId()}subscribeToOffsetChange(e){return this.internalMonitor.subscribeToOffsetChange(e)}canDragSource(e){return this.internalMonitor.canDragSource(e)}canDropOnTarget(e){return this.internalMonitor.canDropOnTarget(e)}getItemType(){return this.internalMonitor.getItemType()}getItem(){return this.internalMonitor.getItem()}getDropResult(){return this.internalMonitor.getDropResult()}didDrop(){return this.internalMonitor.didDrop()}getInitialClientOffset(){return this.internalMonitor.getInitialClientOffset()}getInitialSourceClientOffset(){return this.internalMonitor.getInitialSourceClientOffset()}getSourceClientOffset(){return this.internalMonitor.getSourceClientOffset()}getClientOffset(){return this.internalMonitor.getClientOffset()}getDifferenceFromInitialOffset(){return this.internalMonitor.getDifferenceFromInitialOffset()}constructor(e){this.sourceId=null,this.internalMonitor=e.getMonitor()}}var D=r(4410);class v{beginDrag(){let e=this.spec,t=this.monitor,r=null;return null!=(r="object"==typeof e.item?e.item:"function"==typeof e.item?e.item(t):{})?r:null}canDrag(){let e=this.spec,t=this.monitor;return"boolean"==typeof e.canDrag?e.canDrag:"function"!=typeof e.canDrag||e.canDrag(t)}isDragging(e,t){let r=this.spec,n=this.monitor,{isDragging:i}=r;return i?i(n):t===e.getSourceId()}endDrag(){let e=this.spec,t=this.monitor,r=this.connector,{end:n}=e;n&&n(t.getItem(),t),r.reconnect()}constructor(e,t,r){this.spec=e,this.monitor=t,this.connector=r}}function I(e,t){let r=(0,o.I)(e,t);(0,n.V)(!r.begin,"useDrag::spec.begin was deprecated in v14. Replace spec.begin() with spec.item(). (see more here - https://react-dnd.github.io/react-dnd/docs/api/use-drag)");let a=function(){let e=(0,u.u)();return(0,s.useMemo)(()=>new f(e),[e])}(),c=function(e,t){let r=(0,u.u)(),n=(0,s.useMemo)(()=>new l(r.getBackend()),[r]);return(0,g.E)(()=>(n.dragSourceOptions=e||null,n.reconnect(),()=>n.disconnectDragSource()),[n,e]),(0,g.E)(()=>(n.dragPreviewOptions=t||null,n.reconnect(),()=>n.disconnectDragPreview()),[n,t]),n}(r.options,r.previewOptions),d=(0,u.u)(),h=function(e,t,r){let n=(0,s.useMemo)(()=>new v(e,t,r),[t,r]);return(0,s.useEffect)(()=>{n.spec=e},[e]),n}(r,a,c),p=(0,s.useMemo)(()=>{let e=r.type;return(0,n.V)(null!=e,"spec.type must be defined"),e},[r]);return(0,g.E)(function(){if(null!=p){let[e,t]=(0,D.V)(p,h,d);return a.receiveHandlerId(e),c.receiveHandlerId(e),t}},[d,a,c,h,p]),[(0,i.j)(r.collect,a,c),(0,s.useMemo)(()=>c.hooks.dragSource(),[c]),(0,s.useMemo)(()=>c.hooks.dragPreview(),[c])]}},7172:(e,t,r)=>{r.d(t,{i:()=>n});function n(e){return null!==e&&"object"==typeof e&&Object.prototype.hasOwnProperty.call(e,"current")}},8026:(e,t,r)=>{r.d(t,{E:()=>i});var n=r(4232);let i="undefined"!=typeof window?n.useLayoutEffect:n.useEffect},8333:(e,t,r)=>{r.d(t,{j:()=>s});var n=r(4349),i=r(4232),o=r(8026);function s(e,t,r){return function(e,t,r){let[s,a]=function(e,t,r){let[s,a]=(0,i.useState)(()=>t(e)),c=(0,i.useCallback)(()=>{let i=t(e);!n(s,i)&&(a(i),r&&r())},[s,e,r]);return(0,o.E)(c),[s,c]}(e,t,r);return(0,o.E)(function(){let t=e.getHandlerId();if(null!=t)return e.subscribeToStateChange(a,{handlerIds:[t]})},[e,a]),s}(t,e||(()=>({})),()=>r.reconnect())}},9006:(e,t,r)=>{r.d(t,{i:()=>o});var n=r(8121),i=r(4232);function o(e){let t={};return Object.keys(e).forEach(r=>{let o=e[r];if(r.endsWith("Ref"))t[r]=e[r];else{let e=(e=null,t=null)=>(0,i.isValidElement)(e)?(!function(e){if("string"==typeof e.type)return;let t=e.type.displayName||e.type.name||"the component";throw Error(`Only native element nodes can now be passed to React DnD connectors.You can either wrap ${t} into a <div>, or turn it into a drag source or a drop target itself.`)}(e),function(e,t){let r=e.ref;return((0,n.V)("string"!=typeof r,"Cannot connect React DnD to an element with an existing string ref. Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs"),r)?(0,i.cloneElement)(e,{ref:e=>{s(r,e),s(t,e)}}):(0,i.cloneElement)(e,{ref:t})}(e,t?e=>o(e,t):o)):(o(e,t),e);t[r]=()=>e}}),t}function s(e,t){"function"==typeof e?e(t):e.current=t}}}]);